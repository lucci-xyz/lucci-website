export const metadata = { 
  title: 'Smart Contracts — Lucci Labs',
  description: 'Smart contract libraries and utilities'
}

# Smart Contracts

Lucci Labs maintains several smart contract libraries and utilities for DeFi and Web3 development.

## FeeVault

Minimal owner-controlled vault for fee aggregation and sweeps.

**Status:** Experimental  
**Use Case:** Fee collection, revenue aggregation

### Overview

FeeVault is a lightweight smart contract for collecting and managing protocol fees. It provides a secure, owner-controlled vault for aggregating fees from multiple sources and performing batch withdrawals.

### Key Features

- Owner-controlled access
- Multi-token support
- Gas-efficient batch operations
- Emergency withdrawal functions
- Event logging for tracking

### Basic Usage

```solidity
// Deploy FeeVault
FeeVault vault = new FeeVault(owner);

// Deposit fees (called by protocol contracts)
vault.deposit{value: amount}();

// Sweep fees to owner
vault.sweep(tokenAddress);
```

### Contract Interface

```solidity
interface IFeeVault {
    function deposit() external payable;
    function sweep(address token) external;
    function emergencyWithdraw(address token, uint256 amount) external;
}
```

### Integration Example

```solidity
contract MyProtocol {
    IFeeVault public feeVault;
    
    constructor(address _feeVault) {
        feeVault = IFeeVault(_feeVault);
    }
    
    function collectFee() internal {
        uint256 fee = calculateFee();
        feeVault.deposit{value: fee}();
    }
}
```

[View Source →](https://github.com/LucciCapital/fee-vault)

## RiskLedger

Merkle-anchored weekly risk roots for protocol decisions.

**Status:** Research  
**Use Case:** Risk management, protocol governance

### Overview

RiskLedger is a research project exploring on-chain risk management using Merkle trees. It maintains weekly risk assessments as Merkle roots, allowing protocols to make informed decisions based on historical risk data.

### Concept

- Weekly snapshots of risk metrics
- Merkle tree structure for efficient verification
- On-chain anchoring for transparency
- Off-chain computation, on-chain verification

### Risk Metrics

RiskLedger tracks various risk indicators:
- Liquidity risk
- Counterparty risk
- Smart contract risk
- Market volatility

### Verification Example

```solidity
function verifyRiskScore(
    bytes32 root,
    bytes32[] calldata proof,
    address account,
    uint256 score
) public view returns (bool) {
    bytes32 leaf = keccak256(abi.encodePacked(account, score));
    return MerkleProof.verify(proof, root, leaf);
}
```

### Use Cases

**Dynamic Rate Adjustment**
```solidity
uint256 riskScore = getRiskScore(borrower, proof);
uint256 rate = baseRate + (riskScore * riskPremium);
```

**Access Control**
```solidity
require(riskScore < maxRisk, "Risk too high");
```

**Collateral Requirements**
```solidity
uint256 collateral = amount * (100 + riskScore) / 100;
```

[View Source →](https://github.com/LucciCapital)

## Development Guidelines

### Testing

All smart contracts should include comprehensive tests:

```bash
# Install dependencies
npm install

# Run tests
npm test

# Coverage
npm run coverage
```

### Deployment

Use deployment scripts for consistency:

```typescript
import { ethers } from 'hardhat'

async function deploy() {
  const FeeVault = await ethers.getContractFactory('FeeVault')
  const vault = await FeeVault.deploy(ownerAddress)
  await vault.deployed()
  
  console.log('FeeVault deployed:', vault.address)
}
```

### Security

- Always audit contracts before mainnet deployment
- Use established libraries (OpenZeppelin)
- Follow best practices for access control
- Test edge cases and failure scenarios
- Monitor deployed contracts

## Best Practices

### Gas Optimization

```solidity
// Use calldata for read-only arrays
function process(uint256[] calldata data) external {
    // More gas efficient than memory
}

// Pack storage variables
struct Config {
    uint128 value1;
    uint128 value2;  // Fits in single slot
}
```

### Access Control

```solidity
import "@openzeppelin/contracts/access/Ownable.sol";

contract MyContract is Ownable {
    function adminFunction() external onlyOwner {
        // Protected function
    }
}
```

### Event Emission

```solidity
event FeeCollected(address indexed token, uint256 amount);

function collectFee(address token, uint256 amount) external {
    // Logic here
    emit FeeCollected(token, amount);
}
```

## Resources

- [Solidity Documentation](https://docs.soliditylang.org/)
- [OpenZeppelin Contracts](https://docs.openzeppelin.com/contracts/)
- [Ethereum Development](https://ethereum.org/en/developers/)
- [Hardhat Framework](https://hardhat.org/docs)

## Need Help?

- Report issues on [GitHub](https://github.com/LucciCapital)
- Join discussions in our community
- Check existing code examples in repositories
